<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>CECHAT - CEC CHAT</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/gh/Akshay-152/akshay/disabled.js"></script>
  
  
  <!--  -->
  
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Akshay-152/cec1/cec1.css">

    <style>
        /* Additional styles can go here */

        /* Push UI */
.push-controls { margin-top: 12px; display:flex; flex-direction:column; gap:8px; }
.push-controls button { padding:10px 12px; border-radius:8px; border:0; cursor:pointer; font-weight:600; }
.push-status { font-size:13px; color:var(--text-color); opacity:0.8; }
.push-log { max-height:120px; overflow:auto; background:rgba(0,0,0,0.03); padding:8px; border-radius:8px; font-size:13px; }

    </style>
</head>
<body>
    <div class="chat-container">
        <header class="chat-header">
            <div class="header-left">
                <h1><i class="fas fa-comments"></i> CECHAT</h1>
                <div class="user-indicator">
                    <span class="user-color-badge" id="userColorBadge"></span>
                    <span id="userName">You</span>
                </div>
            </div>
            <div class="header-right">
                <div class="message-counter">
                    <span id="messageCount">0/40</span>
                    <span class="counter-label">Today</span>
                </div>
                <button id="themeToggle" class="theme-btn">
                    <i class="fas fa-palette"></i>
                </button>
                <button id="menuButton" class="menu-btn">
                    <i class="fas fa-bars"></i>
                </button>
            </div>
        </header>

        <div class="messages-container" id="messagesContainer">
            <div class="system-message">
                <i class="fas fa-info-circle"></i> 
                Your messages will be automatically deleted after 1-3 days (minimize using bad words)
            </div>
        </div>

        <div class="floating-input-container">
            <div id="replyIndicator" class="reply-indicator" style="display: none;">
                <div class="reply-content">
                    <strong>Replying to:</strong> 
                    <span id="replyText"></span>
                </div>
                <button class="cancel-reply" id="cancelReply">
                    <i class="fas fa-times"></i>
                </button>
            </div>

            <div class="input-group">
                <textarea id="messageInput" placeholder="Type a message..." maxlength="500" rows="1"></textarea>
                <button id="sendButton" class="send-btn">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
         
        </div>

        <div class="menu-overlay" id="menuOverlay"></div>
        <div class="menu-panel" id="menuPanel">
            <div class="menu-header">
                <h2>Settings</h2>
                <button class="cancel-reply" id="closeMenu">
                    <i class="fas fa-times"></i>
                </button>
            </div>

            <div class="menu-section">
                <h3>Your Profile</h3>
                 <div class="chat-info">
                   
        
                
                <span class="timestamp" id="currentTime"></span>
                   
             

   
            </div>
                <input type="text" id="userNameInput" class="name-input" placeholder="Enter your name (optional)" maxlength="20">
                <button class="color-change-btn" id="changeColorBtn">
                    <i class="fas fa-sync-alt"></i> Change My Color
                </button>
            </div>

            <div class="menu-section">
                <h3>Theme</h3>
                <div class="theme-options">
                    <div class="theme-option" data-theme="light">Light</div>
                    <div class="theme-option" data-theme="dark">Dark</div>
                    <div class="theme-option" data-theme="ocean">Ocean</div>
                    <div class="theme-option" data-theme="sunset">Sunset</div>
                    <div class="theme-option" data-theme="forest">Forest</div>
                </div>
            </div>

            <div class="menu-section">
                <h3>Chat Info</h3>
                <div class="info-text">
                    <p><strong>Messages:</strong> <span id="menuMessageCount">0</span>/40 today</p>
                    <p><strong>Expiry:</strong> 1-2 days</p>
                    <p><strong>Features:</strong> Click messages to reply</p>
                </div>
            </div>


            <!-- Notifications menu-section (paste inside menu panel) -->
<div class="menu-section">
  <h3>Notifications</h3>
  <div class="push-controls">
    <button id="btnEnablePush">Enable Notifications</button>
    <button id="btnUnsubPush" class="policyButton">Unsubscribe</button>
    <button id="btnLocalPush" class="policyButton">Send Notification (local)</button>
    <div class="push-status" id="pushStatus">Status: idle</div>
    <div class="push-log" id="pushLog"></div>
  </div>
  
</div>

          
          <div class="menu-section">
          <div id="policySection">

  <button class="policyButton">^ Policy Button</button>

  <div class="policyContent">

    
   <p>
  By accessing and using this web app, you agree to use it responsibly and in compliance with all applicable laws. Messages sent by users, including anonymous ones, are their sole responsibility. The developer is not liable for any misuse, offensive content, or illegal activity conducted through this platform. Minimal data is collected only for communication purposes and is kept secure. By using this site, you acknowledge that the services are provided "as is" without any warranties, and you accept that the developer cannot be held responsible for any issues or damages arising from user actions.
</p>    
    
        <br>

  </div>

    

</div>
          </div>

            <div class="menu-section">
                <h3>Developer</h3>
                <div class="info-text" style="text-align: center; font-size: 1rem; font-weight: 600; color: var(--accent-color); margin-top: 0.5rem;">
                <!--ANONYMOUS-->    <p><b>ANONYMOUS</b></p>
                </div>
            </div>
        </div>

        <div class="toast" id="toast"></div>
    </div>




  
 
  
  
  
  
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
        
import {
  getFirestore,
  collection,
  addDoc,
  onSnapshot,
  query,
  orderBy,
  serverTimestamp,
  where,
  getDocs,
  writeBatch,
  deleteDoc,
  doc,
  setDoc,
  getDoc,
  updateDoc
} from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js';
        
        
        
        const firebaseConfig = {
            apiKey: "AIzaSyC-ft54KwehdTIsV93xBjLbd0nMeZ4ibDw",
            authDomain: "akshay-b744a.firebaseapp.com",
            projectId: "akshay-b744a",
            storageBucket: "akshay-b744a.firebasestorage.app",
            messagingSenderId: "752091661451",
            appId: "1:752091661451:web:7ccfa46feff8ce87c6808e",
            measurementId: "G-GKLRSSBRXR"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        const MAX_MESSAGES_PER_DAY = 40;
        const MESSAGE_EXPIRY_DAYS = 1;

        const messagesContainer = document.getElementById('messagesContainer');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const themeToggle = document.getElementById('themeToggle');
        const menuButton = document.getElementById('menuButton');
        const menuPanel = document.getElementById('menuPanel');
        const menuOverlay = document.getElementById('menuOverlay');
        const closeMenu = document.getElementById('closeMenu');
        const userNameInput = document.getElementById('userNameInput');
        const changeColorBtn = document.getElementById('changeColorBtn');
        const userColorBadge = document.getElementById('userColorBadge');
        const messageCount = document.getElementById('messageCount');
        const menuMessageCount = document.getElementById('menuMessageCount');
        const currentTime = document.getElementById('currentTime');
        const replyIndicator = document.getElementById('replyIndicator');
        const replyText = document.getElementById('replyText');
        const cancelReply = document.getElementById('cancelReply');
        const toast = document.getElementById('toast');
        const themeOptions = document.querySelectorAll('.theme-option');

        let userId = localStorage.getItem('userId') || generateUserId();
        let userName = localStorage.getItem('userName') || "You";
        let userColor = localStorage.getItem('userColor') || generateRandomColor();
        let messagesSentToday = 0;
        let replyingTo = null;
        let isInitialLoad = true;
        let existingMessageIds = new Set();

        function generateUserId() {
            const id = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('userId', id);
            return id;
        }

        function generateRandomColor() {
            const colors = [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
                '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B195', '#F67280',
                '#C06C84', '#6C5B7B', '#355C7D', '#2ECC71', '#3498DB',
                '#9B59B6', '#E74C3C', '#1ABC9C', '#F39C12', '#D35400'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }




        function updateUI() {
            userColorBadge.style.backgroundColor = userColor;
            document.getElementById('userName').textContent = userName;
            userNameInput.value = userName === "You" ? "" : userName;
        }

        function updateMessageCounter() {
            const count = `${messagesSentToday}/${MAX_MESSAGES_PER_DAY}`;
            messageCount.textContent = count;
            menuMessageCount.textContent = messagesSentToday;
        }

        function updateTime() {
            const now = new Date();
            currentTime.textContent = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }

        function loadMessageCount() {
            const data = localStorage.getItem('chatData');
            if (data) {
                const parsed = JSON.parse(data);
                const today = new Date().toDateString();
                if (parsed.date === today) {
                    messagesSentToday = parsed.count || 0;
                } else {
                    messagesSentToday = 0;
                    saveMessageCount();
                }
            }
            updateMessageCounter();
        }

        function saveMessageCount() {
            const today = new Date().toDateString();
            const data = { date: today, count: messagesSentToday };
            localStorage.setItem('chatData', JSON.stringify(data));
        }

        function canSendMessage() {
            if (messagesSentToday >= MAX_MESSAGES_PER_DAY) {
                showToast('Daily message limit reached (40 messages)');
                return false;
            }
            return true;
        }




async function sendMessage() {
  const messageText = messageInput.value.trim();
  if (!messageText) return;
  if (!canSendMessage()) return;

  // Check if current local userId is banned
  const localUserId = userId; // your generated id
  const bannedNow = await isBanned(localUserId);
  if (bannedNow) {
    showToast('You are banned from sending messages (reported).');
    return;
  }

  // --- continue with original message building and addDoc call ---
  const message = {
      text: messageText,
      color: userColor,
      sender: userName === "You" ? "Anonymous" : userName,
      userId: userId,
      timestamp: serverTimestamp(),
      type: 'user',
      expiresAt: new Date(Date.now() + MESSAGE_EXPIRY_DAYS * 24 * 60 * 60 * 1000),
      replyTo: replyingTo
  };

  try {
      await addDoc(collection(db, 'messages'), message);
      messageInput.value = '';
      messageInput.style.height = 'auto';
      cancelReplyTo();
      messagesSentToday++;
      saveMessageCount();
      updateMessageCounter();
      scrollToBottom();
  } catch (error) {
      console.error('Error sending message:', error);
      showToast('Error sending message');
  }
}

        
        
        
                
        
        
        
        

        function loadMessages() {
            if (!document.querySelector('.system-message')) {
                const systemMsg = document.createElement('div');
                systemMsg.className = 'system-message';
                systemMsg.innerHTML = `<i class="fas fa-info-circle"></i> Your messages will be automatically deleted after 3 days`;
                messagesContainer.appendChild(systemMsg);
            }
            
            const q = query(collection(db, 'messages'), orderBy('timestamp', 'asc'));
            
            onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'added') {
                        const message = change.doc.data();
                        const messageId = change.doc.id;
                        
                        if (!isMessageExpired(message)) {
                            const isNewMessage = !existingMessageIds.has(messageId) && !isInitialLoad;
                            existingMessageIds.add(messageId);
                            
                            if (isNewMessage) {
                                setTimeout(() => {
                                    displayMessage(message, messageId, true);
                                    scrollToBottom();
                                }, 1000);
                            } else {
                                displayMessage(message, messageId, false);
                            }
                        }
                    }
                });
                
                if (isInitialLoad) {
                    isInitialLoad = false;
                    scrollToBottom();
                }
            });
        }
        
        
        
        




function displayMessage(message, messageId, isNewMessage = false) {
    if (isMessageExpired(message)) return;

    const messageDiv = document.createElement('div');
    const isCurrentUser = message.userId === userId;

    messageDiv.className = `message ${isCurrentUser ? 'user-message' : 'other-message'} ${isNewMessage ? 'new-message' : ''}`;
    messageDiv.dataset.messageId = messageId;

    const timestamp = message.timestamp
        ? message.timestamp.toDate().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        : new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    let replySection = '';
    if (message.replyTo) {
        const repliedMessage = message.replyTo;
        replySection = `
            <div class="reply-preview">
                <div class="reply-sender" style="color: rgba(255,255,255,0.9)">
                    <i class="fas fa-reply"></i> ${repliedMessage.sender || 'Anonymous'}
                </div>
                ${repliedMessage.text}
            </div>
        `;
    }

    let messageStyle;
    let senderNameStyle = '';
    if (message.sender === 'cecchatadmine1') {
        message.sender = 'ADMIN';
        messageStyle = 'background: black !important; color: white !important; box-shadow: 0 0 12px rgba(255,255,255,0.6);';
        senderNameStyle = 'color: white !important; font-size: 1.1rem; font-weight: 700; text-shadow: 0 0 8px rgba(255,255,255,0.8);';
    } else {
        messageStyle = `background: ${message.color} !important;`;
    }

    messageDiv.innerHTML = `
        <div class="message-bubble" style="${messageStyle}" data-message-id="${messageId}">
            ${!isCurrentUser ? `
                <div class="message-sender" style="${senderNameStyle}">
                    <span class="sender-color" style="background-color: ${message.color}"></span>
                    ${message.sender || 'Anonymous'}
                </div>
            ` : ''}
            ${replySection}
            <div class="message-text">${message.text}</div>
            <div class="message-time">
                ${timestamp}
                ${getExpiryInfo(message)}
            </div>
        </div>
    `;

    // Reply on click
    messageDiv.querySelector('.message-bubble').addEventListener('click', () => {
        replyToMessage(messageId, message.text, message.color, message.sender);
    });

    // Long-press for admin (3 seconds)
    const bubble = messageDiv.querySelector('.message-bubble');
    let longPressTimer = null;

    const startPress = (ev) => {
        // admin check: either runtime userName or stored localStorage userName
        const storedName = localStorage.getItem('userName');
        if (userName !== 'cecchatadmine1' && storedName !== 'cecchatadmine1') return;

        longPressTimer = setTimeout(() => {
            let x = (ev.touches && ev.touches[0]) ? ev.touches[0].clientX : ev.clientX;
            let y = (ev.touches && ev.touches[0]) ? ev.touches[0].clientY : ev.clientY;

            showAdminMenuAt(x, y, {
                onDelete: () => deleteMessage(messageId),
                onReport: () => reportSender(message.userId)
            });
        }, 1000); // 1 seconds
    };

    const cancelPress = () => {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
    };

    // Mouse
    bubble.addEventListener('mousedown', startPress);
    bubble.addEventListener('mouseup', cancelPress);
    bubble.addEventListener('mouseleave', cancelPress);

    // Touch
    bubble.addEventListener('touchstart', startPress);
    bubble.addEventListener('touchend', cancelPress);
    bubble.addEventListener('touchcancel', cancelPress);

    messagesContainer.appendChild(messageDiv);
}



  

/* Paste this inside your existing type="module" script (after db and userId are declared) */

const VAPID_PUBLIC_KEY = 'BFac02acpDf3FjJIJCUwrRpSe9LWwW65O27NS5hZSCXBNVzhLG57y-m1anIEwTnjZz4X5iXCCj6CV8HTadydQpM';

function logPush(msg){
  const t = new Date().toLocaleTimeString();
  const el = document.getElementById('pushLog');
  if(!el) return;
  el.innerHTML = `<div style="padding:6px 0;border-bottom:1px dashed rgba(0,0,0,0.05)"><strong>[${t}]</strong> ${msg}</div>` + el.innerHTML;
  console.log('[push]', msg);
}

function urlBase64ToUint8Array(base64String){
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding).replace(/-/g,'+').replace(/_/g,'/');
  const raw = window.atob(base64);
  const output = new Uint8Array(raw.length);
  for(let i=0;i<raw.length;++i) output[i] = raw.charCodeAt(i);
  return output;
}

async function ensureSW() {
  try {
    const reg = await navigator.serviceWorker.register('/sw.js');
    logPush('Service worker registered (scope: ' + (reg.scope || 'unknown') + ')');
    document.getElementById('pushStatus').textContent = 'Status: sw registered';
    return reg;
  } catch (e) {
    logPush('SW register failed: ' + e.message);
    document.getElementById('pushStatus').textContent = 'Status: sw failed';
    throw e;
  }
}

async function subscribeAndSave(){
  try{
    if(Notification.permission === 'default') await Notification.requestPermission();
    if(Notification.permission !== 'granted'){
      document.getElementById('pushStatus').textContent = 'Status: permission denied';
      logPush('Notification permission denied');
      return null;
    }
    const reg = await ensureSW();
    const existing = await reg.pushManager.getSubscription();
    if(existing){
      document.getElementById('pushStatus').textContent = 'Status: already subscribed';
      logPush('Found existing subscription â€” saving/updating in Firestore');
      await saveSubscriptionToFirestore(existing);
      return existing;
    }
    const sub = await reg.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
    });
    await saveSubscriptionToFirestore(sub);
    document.getElementById('pushStatus').textContent = 'Status: subscribed';
    logPush('Subscribed and saved to Firestore');
    return sub;
  }catch(e){
    document.getElementById('pushStatus').textContent = 'Status: subscribe error';
    logPush('Subscribe error: ' + (e.message || e));
    return null;
  }
}

async function saveSubscriptionToFirestore(sub){
  try{
    const subDocRef = doc(db, 'push_subscriptions', userId);
    const subData = {
      subscription: JSON.parse(JSON.stringify(sub)),
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      userAgent: navigator.userAgent
    };
    await setDoc(subDocRef, subData, { merge: true });
    logPush('Saved subscription to Firestore: push_subscriptions/' + userId);
  }catch(e){
    logPush('Error saving subscription: ' + e.message);
    throw e;
  }
}

async function unsubscribeAndRemove(){
  try{
    const reg = await navigator.serviceWorker.getRegistration();
    if(!reg){ document.getElementById('pushStatus').textContent = 'Status: no sw'; logPush('No SW to get subscription from'); return; }
    const sub = await reg.pushManager.getSubscription();
    if(!sub){ document.getElementById('pushStatus').textContent = 'Status: no subscription'; logPush('No active subscription'); return; }
    const ok = await sub.unsubscribe();
    if(ok){
      await deleteDoc(doc(db, 'push_subscriptions', userId)).catch(()=>{});
      document.getElementById('pushStatus').textContent = 'Status: unsubscribed';
      logPush('Unsubscribed and removed Firestore entry');
    } else {
      document.getElementById('pushStatus').textContent = 'Status: unsubscribe failed';
      logPush('Unsubscribe returned false');
    }
  }catch(e){
    document.getElementById('pushStatus').textContent = 'Status: unsubscribe error';
    logPush('Unsubscribe error: ' + e.message);
  }
}

async function sendLocalNotification(){
  try{
    const reg = await navigator.serviceWorker.getRegistration();
    if(!reg) throw new Error('No service worker');
    if(Notification.permission !== 'granted'){
      await Notification.requestPermission();
      if(Notification.permission !== 'granted') throw new Error('Permission not granted');
    }
    const payload = { title: 'Hello!', body: 'This is a client demo notification.', url: '/' };
    await reg.showNotification(payload.title, {
      body: payload.body,
      data: { url: payload.url },
      tag: 'demo-push',
      renotify: true
    });
    document.getElementById('pushStatus').textContent = 'Status: local notification shown';
    logPush('Local notification shown via SW');
  }catch(e){
    document.getElementById('pushStatus').textContent = 'Status: send failed';
    logPush('Send local error: ' + e.message);
  }
}

/* wire up push UI */
document.getElementById('btnEnablePush').addEventListener('click', async ()=>{
  const btn = document.getElementById('btnEnablePush');
  btn.disabled = true;
  try { await subscribeAndSave(); } catch(e) { logPush('Enable click error: ' + e.message); }
  finally { btn.disabled = false; }
});
document.getElementById('btnUnsubPush').addEventListener('click', async ()=>{
  const btn = document.getElementById('btnUnsubPush');
  btn.disabled = true;
  try { await unsubscribeAndRemove(); } catch(e) { logPush('Unsub click error: ' + e.message); }
  finally { btn.disabled = false; }
});
document.getElementById('btnLocalPush').addEventListener('click', async ()=>{
  const btn = document.getElementById('btnLocalPush');
  btn.disabled = true;
  try { await sendLocalNotification(); } catch(e) { logPush('Local push error: ' + e.message); }
  finally { btn.disabled = false; }
});

/* ensureSW on load */
window.addEventListener('load', async () => { try{ await ensureSW(); }catch(e){ console.warn('sw reg failed', e); } });

/* listen for RESUBSCRIBE from sw.js */
navigator.serviceWorker?.addEventListener?.('message', (ev)=>{ if(ev?.data === 'RESUBSCRIBE') { logPush('RESUBSCRIBE from SW'); subscribeAndSave().catch(err=>logPush('resub failed:'+err)); } });


 



// ---------------- Admin helpers: menu, delete, report, ban check ----------------

// Returns true if the current local user is admin
function isCurrentUserAdmin() {
  const storedName = localStorage.getItem('userName');
  return userName === 'cecchatadmine1' || storedName === 'cecchatadmine1';
}

// Create & show admin menu near the pointer (x,y). handlers: { onDelete, onReport }
function showAdminMenuAt(x, y, handlers = {}) {
  // remove old menu if present
  const existing = document.getElementById('adminActionMenu');
  if (existing) existing.remove();

  const menu = document.createElement('div');
  menu.id = 'adminActionMenu';
  menu.style.position = 'fixed';
  menu.style.left = (x + 6) + 'px';
  menu.style.top = (y + 6) + 'px';
  menu.style.zIndex = 2000;
  menu.style.padding = '8px';
  menu.style.borderRadius = '8px';
  menu.style.background = 'var(--secondary-bg)';
  menu.style.color = 'var(--text-color)';
  menu.style.boxShadow = '0 6px 18px rgba(0,0,0,0.2)';
  menu.style.display = 'flex';
  menu.style.flexDirection = 'column';
  menu.style.gap = '6px';
  menu.style.minWidth = '140px';
  menu.style.border = '1px solid var(--border-color)';

  const createBtn = (text) => {
    const b = document.createElement('button');
    b.textContent = text;
    b.style.padding = '8px';
    b.style.border = 'none';
    b.style.cursor = 'pointer';
    b.style.borderRadius = '6px';
    b.style.fontWeight = '700';
    b.style.background = 'transparent';
    b.style.textAlign = 'left';
    b.addEventListener('mouseover', () => b.style.background = 'rgba(0,0,0,0.06)');
    b.addEventListener('mouseout', () => b.style.background = 'transparent');
    return b;
  };

  const delBtn = createBtn('Delete');
  delBtn.addEventListener('click', () => { if (handlers.onDelete) handlers.onDelete(); menu.remove(); });

  const repBtn = createBtn('Report (ban 1 day)');
  repBtn.addEventListener('click', () => { if (handlers.onReport) handlers.onReport(); menu.remove(); });

  const cancelBtn = createBtn('Cancel');
  cancelBtn.addEventListener('click', () => menu.remove());

  menu.appendChild(delBtn);
  menu.appendChild(repBtn);
  menu.appendChild(cancelBtn);

  document.body.appendChild(menu);

  // click-away removes menu
  const clickAway = (e) => {
    if (!menu.contains(e.target)) {
      menu.remove();
      window.removeEventListener('pointerdown', clickAway);
    }
  };
  window.addEventListener('pointerdown', clickAway);
}

// Delete message doc from Firestore
async function deleteMessage(messageId) {
  if (!messageId) return;
  const ok = confirm('Delete this message? This action cannot be undone.');
  if (!ok) return;
  try {
    await deleteDoc(doc(db, 'messages', messageId));
    showToast('Message deleted');
  } catch (err) {
    console.error('deleteMessage error', err);
    showToast('Failed to delete message');
  }
}

// Report sender: ban userId for 24 hours (create/update doc in bannedUsers collection)
async function reportSender(userId) {
  if (!userId) {
    showToast('Cannot report: no user id');
    return;
  }
  const ok = confirm('Report this sender. They will be blocked for 24 hours. Continue?');
  if (!ok) return;
  try {
    const banUntil = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours
    await setDoc(doc(db, 'bannedUsers', userId), {
      bannedUntil: banUntil
    });
    showToast('Sender reported and banned for 24 hours');
  } catch (err) {
    console.error('reportSender error', err);
    showToast('Failed to report sender');
  }
}

// Check if a given userId is currently banned
async function isBanned(userId) {
  if (!userId) return false;
  try {
    const d = await getDoc(doc(db, 'bannedUsers', userId));
    if (!d.exists()) return false;
    const data = d.data();
    const bannedUntil = data && data.bannedUntil ? (data.bannedUntil.toDate ? data.bannedUntil.toDate() : new Date(data.bannedUntil)) : null;
    if (!bannedUntil) return false;
    return new Date() < bannedUntil;
  } catch (err) {
    console.error('isBanned error', err);
    return false;
  }
}







        function replyToMessage(messageId, text, color, sender) {
            replyingTo = {
                messageId: messageId,
                text: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
                color: color,
                sender: sender || 'Anonymous'
            };
            
            replyText.textContent = replyingTo.text;
            replyIndicator.style.display = 'flex';
            messageInput.focus();
            closeMenuPanel();
        }

        function cancelReplyTo() {
            replyingTo = null;
            replyIndicator.style.display = 'none';
        }

        function isMessageExpired(message) {
            if (!message.expiresAt) return false;
            const expiryDate = message.expiresAt.toDate ? 
                message.expiresAt.toDate() : new Date(message.expiresAt);
            return new Date() > expiryDate;
        }

        function getExpiryInfo(message) {
            if (!message.expiresAt) return '';
            
            const expiryDate = message.expiresAt.toDate ? 
                message.expiresAt.toDate() : new Date(message.expiresAt);
            const timeLeft = expiryDate - new Date();
            const daysLeft = Math.ceil(timeLeft / (1000 * 60 * 60 * 24));
            
            if (daysLeft <= 0) {
                return '<div class="expired-badge">Expired</div>';
            } else if (daysLeft === 1) {
                return '<div style="font-size: 0.65rem; opacity: 0.7;">Expires tomorrow</div>';
            } else {
                return `<div style="font-size: 0.65rem; opacity: 0.7;">Expires in ${daysLeft} days</div>`;
            }
        }

        async function cleanExpiredMessages() {
            const threeDaysAgo = new Date(Date.now() - MESSAGE_EXPIRY_DAYS *24*60*60*1000);
            
            try {
                const q = query(collection(db, 'messages'), where('timestamp', '<', threeDaysAgo));
                const snapshot = await getDocs(q);
                
                const batch = writeBatch(db);
                snapshot.forEach(doc => {
                    batch.delete(doc.ref);
                });
                
                await batch.commit();
            } catch (error) {
                console.error('Error cleaning expired messages:', error);
            }
        }

        function scrollToBottom() {
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }

        function showToast(message) {
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        function openMenu() {
            menuPanel.classList.add('active');
            menuOverlay.style.display = 'block';
            setTimeout(() => menuOverlay.style.opacity = '1', 10);
        }

        function closeMenuPanel() {
            menuPanel.classList.remove('active');
            menuOverlay.style.opacity = '0';
            setTimeout(() => menuOverlay.style.display = 'none', 300);
        }

        function setTheme(theme) {
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('chatTheme', theme);
            updateThemeIcon(theme);
        }

        function updateActiveThemeOption(theme) {
            themeOptions.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.theme === theme) {
                    option.classList.add('active');
                }
            });
        }

        function toggleTheme() {
            const currentTheme = document.body.getAttribute('data-theme') || 'light';
            const themes = ['light', 'dark', 'ocean', 'sunset', 'forest'];
            const currentIndex = themes.indexOf(currentTheme);
            const nextIndex = (currentIndex + 1) % themes.length;
            const newTheme = themes[nextIndex];
            
            setTheme(newTheme);
            updateActiveThemeOption(newTheme);
            showToast(`Theme: ${newTheme.charAt(0).toUpperCase() + newTheme.slice(1)}`);
        }

        function updateThemeIcon(theme) {
            const icon = themeToggle.querySelector('i');
            const icons = {
                'light': 'fa-sun',
                'dark': 'fa-moon',
                'ocean': 'fa-water',
                'sunset': 'fa-cloud-sun',
                'forest': 'fa-tree'
            };
            icon.className = `fas ${icons[theme] || 'fa-palette'}`;
        }


function updateUserName(e) {
  userName = e.target.value.trim() || "You";
  localStorage.setItem('userName', userName);
  updateUI();
  showToast(`Name set to ${userName}`);
}

                
        
        

        function changeUserColor() {
            userColor = generateRandomColor();
            localStorage.setItem('userColor', userColor);
            updateUI();
            showToast('Color changed!');
        }

        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        messageInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 130) + 'px';
        });

        messageInput.addEventListener('focus', function() {
            messagesContainer.classList.add('keyboard-open');
            setTimeout(() => scrollToBottom(), 300);
        });

        messageInput.addEventListener('blur', function() {
            messagesContainer.classList.remove('keyboard-open');
        });

        window.addEventListener('resize', function() {
            if (document.activeElement === messageInput) {
                setTimeout(() => scrollToBottom(), 100);
            }
        });

        themeToggle.addEventListener('click', toggleTheme);
        menuButton.addEventListener('click', openMenu);
        closeMenu.addEventListener('click', closeMenuPanel);
        menuOverlay.addEventListener('click', closeMenuPanel);
        userNameInput.addEventListener('input', updateUserName);
        changeColorBtn.addEventListener('click', changeUserColor);
        cancelReply.addEventListener('click', cancelReplyTo);

        themeOptions.forEach(option => {
            option.addEventListener('click', function() {
                const theme = this.dataset.theme;
                setTheme(theme);
                themeOptions.forEach(opt => opt.classList.remove('active'));
                this.classList.add('active');
                closeMenuPanel();
            });
        });

        updateUI();
        loadMessageCount();
        updateTime();
        setInterval(updateTime, 1000);

        const savedTheme = localStorage.getItem('chatTheme') || 'light';
        setTheme(savedTheme);
        updateActiveThemeOption(savedTheme);

        loadMessages();
        
        setInterval(cleanExpiredMessages, 60 * 60 * 1000);
    </script>
  
  
  <script>

const policyButtons = document.querySelectorAll('.policyButton');

const policyContents = document.querySelectorAll('.policyContent');

policyButtons.forEach((btn, index) => {

  const content = policyContents[index];

  btn.addEventListener('click', () => {

    const isOpen = content.classList.contains('open');

    if(isOpen){

      content.classList.remove('open');

      btn.textContent = btn.textContent.replace('v','^');

    } else {

      content.classList.add('open');

      btn.textContent = btn.textContent.replace('^','v');

    }

  });

});



// small UI logger for push
function logPush(msg){
  const t = new Date().toLocaleTimeString();
  const el = document.getElementById('pushLog');
  if(!el) return;
  el.innerHTML = `<div style="padding:6px 0;border-bottom:1px dashed rgba(0,0,0,0.05)"><strong>[${t}]</strong> ${msg}</div>` + el.innerHTML;
  console.log('[push]', msg);
}

function urlBase64ToUint8Array(base64String){
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding).replace(/-/g,'+').replace(/_/g,'/');
  const raw = window.atob(base64);
  const output = new Uint8Array(raw.length);
  for(let i=0;i<raw.length;++i) output[i] = raw.charCodeAt(i);
  return output;
}


// Step 8: register the same sw.js that you uploaded
async function ensureSW() {
  try {
    const reg = await navigator.serviceWorker.register('/sw.js');
    logPush('Service worker registered (scope: ' + (reg.scope || 'unknown') + ')');
    document.getElementById('pushStatus').textContent = 'Status: sw registered';
    return reg;
  } catch (e) {
    logPush('SW register failed: ' + e.message);
    document.getElementById('pushStatus').textContent = 'Status: sw failed';
    throw e;
  }
}


async function subscribeAndSave(){
  try{
    if(Notification.permission === 'default') await Notification.requestPermission();
    if(Notification.permission !== 'granted'){
      document.getElementById('pushStatus').textContent = 'Status: permission denied';
      logPush('Notification permission denied');
      return null;
    }
    const reg = await ensureSW();
    const existing = await reg.pushManager.getSubscription();
    if(existing){
      document.getElementById('pushStatus').textContent = 'Status: already subscribed';
      logPush('Found existing subscription â€” saving/updating in Firestore');
      await saveSubscriptionToFirestore(existing);
      return existing;
    }
    const sub = await reg.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
    });
    await saveSubscriptionToFirestore(sub);
    document.getElementById('pushStatus').textContent = 'Status: subscribed';
    logPush('Subscribed and saved to Firestore');
    return sub;
  }catch(e){
    document.getElementById('pushStatus').textContent = 'Status: subscribe error';
    logPush('Subscribe error: ' + (e.message || e));
    return null;
  }
}

async function saveSubscriptionToFirestore(sub){
  try{
    // We store under push_subscriptions/{userId}
    const subDocRef = doc(db, 'push_subscriptions', userId);
    const subData = {
      subscription: JSON.parse(JSON.stringify(sub)),
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      userAgent: navigator.userAgent
    };
    await setDoc(subDocRef, subData, { merge: true });
    logPush('Saved subscription to Firestore: push_subscriptions/' + userId);
  }catch(e){
    logPush('Error saving subscription: ' + e.message);
    throw e;
  }
}

async function unsubscribeAndRemove(){
  try{
    const reg = await navigator.serviceWorker.getRegistration();
    if(!reg){ document.getElementById('pushStatus').textContent = 'Status: no sw'; logPush('No SW to get subscription from'); return; }
    const sub = await reg.pushManager.getSubscription();
    if(!sub){ document.getElementById('pushStatus').textContent = 'Status: no subscription'; logPush('No active subscription'); return; }
    const ok = await sub.unsubscribe();
    if(ok){
      await deleteDoc(doc(db, 'push_subscriptions', userId)).catch(()=>{});
      document.getElementById('pushStatus').textContent = 'Status: unsubscribed';
      logPush('Unsubscribed and removed Firestore entry');
    } else {
      document.getElementById('pushStatus').textContent = 'Status: unsubscribe failed';
      logPush('Unsubscribe returned false');
    }
  }catch(e){
    document.getElementById('pushStatus').textContent = 'Status: unsubscribe error';
    logPush('Unsubscribe error: ' + e.message);
  }
}

async function sendLocalNotification(){
  try{
    const reg = await navigator.serviceWorker.getRegistration();
    if(!reg) throw new Error('No service worker');
    if(Notification.permission !== 'granted'){
      await Notification.requestPermission();
      if(Notification.permission !== 'granted') throw new Error('Permission not granted');
    }
    const payload = { title: 'Hello!', body: 'This is a client demo notification.', url: '/' };
    await reg.showNotification(payload.title, {
      body: payload.body,
      data: { url: payload.url },
      tag: 'demo-push',
      renotify: true
    });
    document.getElementById('pushStatus').textContent = 'Status: local notification shown';
    logPush('Local notification shown via SW');
  }catch(e){
    document.getElementById('pushStatus').textContent = 'Status: send failed';
    logPush('Send local error: ' + e.message);
  }
}
/* ---------- end push helpers ---------- */



document.getElementById('btnEnablePush').addEventListener('click', async ()=>{
  const btn = document.getElementById('btnEnablePush');
  btn.disabled = true;
  try { await subscribeAndSave(); } catch(e) { logPush('Enable click error: ' + e.message); }
  finally { btn.disabled = false; }
});

document.getElementById('btnUnsubPush').addEventListener('click', async ()=>{
  const btn = document.getElementById('btnUnsubPush');
  btn.disabled = true;
  try { await unsubscribeAndRemove(); } catch(e) { logPush('Unsub click error: ' + e.message); }
  finally { btn.disabled = false; }
});

document.getElementById('btnLocalPush').addEventListener('click', async ()=>{
  const btn = document.getElementById('btnLocalPush');
  btn.disabled = true;
  try { await sendLocalNotification(); } catch(e) { logPush('Local push error: ' + e.message); }
  finally { btn.disabled = false; }
});


// Step 7: Try to register the service worker on page load (non-blocking)
window.addEventListener('load', async () => {
  try {
    await ensureSW(); // ensureSW() was added in push helpers
  } catch (e) {
    // intentionally ignore - we still want chat to work even if SW fails
    console.warn('sw registration failed (non-blocking):', e);
  }
});

// Step 8: Listen for messages from the service worker (optional)
if (navigator.serviceWorker && navigator.serviceWorker.addEventListener) {
  navigator.serviceWorker.addEventListener('message', (ev) => {
    if (ev?.data === 'RESUBSCRIBE') {
      logPush('Received RESUBSCRIBE from SW â€” attempting to re-subscribe');
      subscribeAndSave().catch(err => logPush('Resubscribe failed: ' + (err.message || err)));
    }
  });
}

// Step 9: Wire up the push buttons (attach event handlers)
const btnEnablePushEl = document.getElementById('btnEnablePush');
const btnUnsubPushEl  = document.getElementById('btnUnsubPush');
const btnLocalPushEl   = document.getElementById('btnLocalPush');

if (btnEnablePushEl) {
  btnEnablePushEl.addEventListener('click', async () => {
    btnEnablePushEl.disabled = true;
    try {
      await subscribeAndSave();
    } catch (e) {
      logPush('Enable click error: ' + (e.message || e));
    } finally {
      btnEnablePushEl.disabled = false;
    }
  });
}

if (btnUnsubPushEl) {
  btnUnsubPushEl.addEventListener('click', async () => {
    btnUnsubPushEl.disabled = true;
    try {
      await unsubscribeAndRemove();
    } catch (e) {
      logPush('Unsubscribe click error: ' + (e.message || e));
    } finally {
      btnUnsubPushEl.disabled = false;
    }
  });
}

if (btnLocalPushEl) {
  btnLocalPushEl.addEventListener('click', async () => {
    btnLocalPushEl.disabled = true;
    try {
      await sendLocalNotification();
    } catch (e) {
      logPush('Local push click error: ' + (e.message || e));
    } finally {
      btnLocalPushEl.disabled = false;
    }
  });
}

window.addEventListener('load', async () => {
  try {
    await ensureSW();
  } catch (e) {
    console.warn('SW registration failed (non-blocking):', e);
  }
  
  // ðŸ‘‡ New addition: show allow-notification prompt once
  promptNotificationPermissionOnce();
});



// Step: Show alert on first visit to ask permission
function promptNotificationPermissionOnce() {
  const alreadyAsked = localStorage.getItem('notifPromptShown');

  // Only show once
  if (alreadyAsked) return;

  // Create a slight delay so UI loads first
  setTimeout(async () => {
    const allow = confirm("ðŸ”” This site can send you updates!\n\nWould you like to enable notifications?");
    if (allow) {
      // User clicked OK, request permission and subscribe using your existing function
      try {
        await subscribeAndSave();
      } catch (e) {
        console.warn("Notification permission setup failed:", e);
      }
    }
    // Mark that we've shown it once
    localStorage.setItem('notifPromptShown', 'true');
  }, 1500); // 1.5 seconds after page load
}

</script>
  
  
</body>
</html>
